#include <stdio.h>

int main(void)
{  
     // '&'
    int A1 = 15; // 00001111 4바이트 지만 앞의 3바이트는 생략
    int A2 = 20; // 00010100
    int A3 = A1 & A2; // & 비트연산자 두 개의 비트가 1일 때 1을 반환
                      // ->00000100 = 4
    printf("And 연산의 결과 : %d \n", A3);

    // '^'
    int B1 = 15; // 00001111
    int B2 = 20; // 00010100
    int B3 = B1 ^ B2; // ^ 비트연산자 두 개의 비트가 서로 다른 경우에 1을 반환
                      // -> 00011011 = 27 
    printf("XOR 연산의 결과: %d \n", B3);

    // '|'
    int C1 = 15; // 00001111
    int C2 = 20; // 00010100
    int C3 = C1 | C2; // | 비트연산자 두 개의 비트중 하나라도 1이면 1을 반환
                      // -> 00011111 = 31
    printf("OR 연산의 결과 : %d \n", C3);

    // '~'
    int D1 = 15; // 00000000 00000000 00000000 00001111
    int D2 = ~D1;     // ~ 비트연산자 0을 1로, 1을 0으로 변환 보수연산이라고도 함
                      // 11111111 11111111 11111111 11110000
                      // 보수 취하면 00000000 00000000 00000000 00010000
                      // -> -16
    printf("NOT 연산의 결과 : %d \n", D2);

    // '<< , >>'
    int E1 = 15; // 00001111

    int result1 = E1 << 1; //E1의 비트 열을 왼쪽으로 1칸 이동
    int result2 = E1 << 2; //E1의 비트 열을 왼쪽으로 2칸 이동
                           // 00011110 00111100 
    printf("1칸 : %d \n", result1);
    printf("2칸 : %d \n", result2);

    int F1 = -16; // 11111111 11111111 11111111 11110000
    printf("2칸>> : %d \n", F1>>2); // -4
    printf("2칸<< : %d \n", F1<<2); // -64
    // F1 을 << 하면 새로 생기는 부분이 0이 생기고 >> 를 하면 새로 생기는 부분이 1이 된다.


    return 0;
}